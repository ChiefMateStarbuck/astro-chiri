---
import { themeConfig } from '@/config'

const fadeAnimation = themeConfig.general.fadeAnimation
---

{fadeAnimation && <meta name="view-transition" content="same-origin" />}

<script is:inline define:vars={{ fadeAnimation }}>
  // Enhanced transition initialization - cache-resistant
  ;(() => {
    let isInitialized = false
    let initCounter = 0

    function initMotionPref(doc = document, force = false) {
      // Force re-initialization even if already done
      if (!force && isInitialized && initCounter < 3) {
        return
      }

      initCounter++

      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches
      const supportsViewTransitions = 'startViewTransition' in document

      doc.documentElement.classList.toggle('reduce-motion', prefersReducedMotion)
      doc.documentElement.classList.toggle(
        'disable-transitions',
        !fadeAnimation || !supportsViewTransitions
      )

      // Dynamically control view transition navigation behavior
      let viewTransitionStyle = doc.getElementById('view-transition-style')

      if (fadeAnimation && supportsViewTransitions && !prefersReducedMotion) {
        // Enable view transition navigation
        if (!viewTransitionStyle) {
          viewTransitionStyle = doc.createElement('style')
          viewTransitionStyle.id = 'view-transition-style'
          viewTransitionStyle.textContent = '@view-transition { navigation: auto; }'
          doc.head.appendChild(viewTransitionStyle)
        }

        // Ensure HTML has correct transition attributes
        if (!doc.documentElement.hasAttribute('transition:animate')) {
          doc.documentElement.setAttribute('transition:animate', 'initial')
        }
      } else {
        // Disable view transition navigation
        if (viewTransitionStyle) {
          viewTransitionStyle.remove()
        }
      }

      doc.documentElement.classList.add('js')
      isInitialized = true
    }

    // Initialize motion preferences with force flag
    function initAll(doc = document, force = false) {
      initMotionPref(doc, force)
    }

    // Immediate initialization
    initAll(document, true)

    // Astro-specific events
    document.addEventListener('astro:before-swap', ({ newDocument }) => {
      initAll(newDocument, true)
    })

    document.addEventListener('astro:page-load', () => {
      initAll(document, true)
    })

    document.addEventListener('astro:after-swap', () => {
      initAll(document, true)
    })

    // Browser navigation events
    window.addEventListener('pageshow', () => {
      // Always re-init on pageshow, especially when coming from cache
      initAll(document, true)
    })

    window.addEventListener('pagehide', () => {
      // Reset state when page is hidden
      isInitialized = false
      initCounter = 0
    })

    // Page visibility changes
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        initAll(document, true)
      }
    })

    // DOM ready states
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        initAll(document, true)
      })
    }

    // Focus events (when user returns to tab)
    window.addEventListener('focus', () => {
      initAll(document, true)
    })

    // Fallback: periodic check using requestIdleCallback with timeout-based control
    const startTime = Date.now()
    const timeoutDuration = 3000 // 3 seconds timeout
    let idleCallbackId = null

    function scheduleNextCheck() {
      const elapsed = Date.now() - startTime

      if (elapsed >= timeoutDuration) {
        return
      }

      initAll(document, true)

      // Schedule next check using requestIdleCallback if available, otherwise use requestAnimationFrame
      if ('requestIdleCallback' in window) {
        idleCallbackId = requestIdleCallback(scheduleNextCheck, { timeout: 1000 })
      } else {
        idleCallbackId = requestAnimationFrame(() => {
          setTimeout(scheduleNextCheck, 500)
        })
      }
    }

    // Start the fallback checks
    scheduleNextCheck()

    // Clean up when page unloads
    window.addEventListener('beforeunload', () => {
      if (idleCallbackId) {
        if ('requestIdleCallback' in window) {
          cancelIdleCallback(idleCallbackId)
        } else {
          cancelAnimationFrame(idleCallbackId)
        }
      }
    })
  })()
</script>
